syntax = "proto3";

package ya_relay_proto;

/*
    Although this protocol follows the Request -> Response pattern to a degree,
    requests and responses are not tied to a common ID.

    1. Connection initialization messages are sent in a sequence;
       messages must not overlap,
    2. Control messages must not be responded to,
    3. Response::Node sent to Request::Node contains a corresponding `node_id`,
    4. Response::Node sent to Request::RandomNode contains the `random` flag,
    5. Response::ReverseConnection sent to Request::ReverseConnection
       the corresponding `node_id`.

    In case of points 3, 4 and 5, if more than one request has been sent,
    all requests must be resolved by a single response.
*/


/*
    a. TCP session initialization
        Server ᐊ─          connect           ── Client
        Server ── [  Control::Challenge    ] ─ᐅ Client

    b. UDP session initialization
        Server ᐊ─ [  Request::Session (E)  ] ── Client
        Server ── [  Control::Challenge    ] ─ᐅ Client

    Server ᐊ─ [  Request::Session      ] ── Client
    Server ── [  Response::Session     ] ─ᐅ Client

    Server ᐊ─ [  Request::Register     ] ── Client
    Server ── [  Response::Register    ] ─ᐅ Client

    (E): empty message
 */

message Packet {
    oneof kind {
        /* Forward forward = 1; */
        Request request = 2;
        Response response = 3;
        Control control = 4;
    }
}

/*
    Forward request to client B sent by client A to the server
    or a forwarded message sent by the server to client B.

    `Forward` serves only as a message type marker (i.e. equal to 1).
    The message is of custom binary format, similar to:

    message Forward {
        bytes session_id = 1;
        uint32 slot = 2; // either sender or receiver slot id
        bytes payload = 3;
    }
*/

/* Requests sent to the server by the client */
message Request {
    bytes session_id = 1; // empty for `Request::Session`
    oneof kind {
        Session session = 10;
        Register register = 20;
        Node node = 30;
        RandomNode random_node = 31;
        Neighbours neighbours = 40;
        ReverseConnection reverse_conn = 50;
        Ping ping = 80;
    }

    message Session {
        bytes challenge_resp = 1;
        bytes node_id = 2;
        bytes public_key = 3;
    }

    message Register {
        /* Listening endpoints */
        repeated Endpoint endpoints = 1;
    }

    message Node {
        /* Remote node ID */
        bytes node_id = 1;
        /* Whether to include public key */
        bool public_key = 2;
    }

    message RandomNode {
        /* Whether to include public key */
        bool public_key = 1;
    }

    message Neighbours {
        uint32 count = 1;
        /* Whether to include public keys */
        bool public_key = 2;
    }

    message ReverseConnection {
        /* Remote node ID */
        bytes node_id = 1;
    }

    message Ping {}
}

/* Responses sent by the server to the client */
message Response {
    bytes session_id = 1;
    StatusCode code = 2;
    oneof kind {
        Session session = 10;
        Register register = 20;
        Node node = 30;
        Neighbours neighbours = 40;
        Pong pong = 80;
    }

    message Session {}

    message Register {
        /* Discovered endpoints */
        repeated Endpoint endpoints = 1;
    }

    message Node {
        bytes node_id = 2;
        bytes public_key = 3;
        repeated Endpoint endpoints = 4;
        uint32 seen_ts = 5;
        uint32 slot = 6;
        /* random node flag */
        bool random = 7;
    }

    message Neighbours {
        repeated Node nodes = 1;
    }

    message ReverseConnection {
        bytes node_id = 1;
    }

    message Pong {}
}

/* Control messages (w/o response) sent by server to the client */
message Control {
    bytes session_id = 1;
    oneof kind {
        Challenge challenge = 10;
        ReverseConnection reverse_conn = 20;
        PauseForwarding pause = 30;
        ResumeForwarding resume = 31;
        StopForwarding stop = 32;
    }

    /* Challenge newly-connected nodes */
    message Challenge {
        enum Kind {
            UNDEFINED = 0;
            SHA3_512_LEADING_ZEROS = 10;
        }

        string version = 1;
        /* Capabilities bit field */
        uint64 caps = 2;

        Kind kind = 3;
        uint64 difficulty = 4;
        bytes challenge = 5;
    }

    /* Connect to another node */
    message ReverseConnection {
        bytes node_id = 1;
        repeated Endpoint endpoints = 2;
    }

    message PauseForwarding {
        uint32 slot = 1;
    }

    message ResumeForwarding {
        uint32 slot = 1;
    }

    message StopForwarding {
        uint32 slot = 1;
        StatusCode code = 3;
    }
}

enum StatusCode {
    UNDEFINED = 0;
    OK = 200;
    BAD_REQUEST = 400;
    UNAUTHORIZED = 401;
    NOT_FOUND = 404;
    TIMEOUT = 408;
    CONFLICT = 409;
    PAYLOAD_TOO_LARGE = 413;
    TOO_MANY_REQUESTS = 429;
    SERVER_ERROR = 500;
    GATEWAY_TIMEOUT = 504;
}

enum Protocol {
    UNSUPPORTED = 0;
    TCP = 6;
    UDP = 17;
}

message Endpoint {
    Protocol protocol = 1;
    string address = 2;
    uint32 port = 3;
}
