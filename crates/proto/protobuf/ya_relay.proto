syntax = "proto3";

package ya_relay_proto;

/*
    1. Requests and responses are tied to a common ID.
    2. Connection initialization messages are sent in a sequence,
    3. Control messages must not be responded to,
    4. Response::Node sent to Request::Node contains a corresponding `node_id`,
    5. Request::Node with empty node_id requests information on a random node.
*/


/*
    Server ᐊ─ [  Request::Session (E) ] ── Client
    Server ── [  Response::Challenge  ] ─ᐅ Client

    Server ᐊ─ [  Request::Session     ] ── Client
    Server ── [  Response::Session    ] ─ᐅ Client

    Server ᐊ─ [  Request::Register    ] ── Client
    Server ── [  Response::Register   ] ─ᐅ Client

    (E): empty session id
 */


/* message Forward {} // (tag = 1) */

message Packet {
    bytes session_id = 2; // empty for `Request::Session`
    oneof kind {
        Request request = 3;
        Response response = 4;
        Control control = 5;
    }
}

/*
    Forward request to client B sent by client A to the server
    or a forwarded message sent by the server to client B.

    `Forward` serves only as a message type marker (i.e. equal to 1).
    The message is of custom binary format, similar to:

    message Forward {
        bytes session_id = 1;
        uint32 slot = 2; // either sender or receiver slot id
        bytes payload = 3;
    }
*/

/* Requests sent to the server by the client */
message Request {
    uint64 request_id = 1;

    oneof kind {
        Session session = 10;
        Register register = 20;
        Node node = 30;
        Slot slot = 31;
        Neighbours neighbours = 40;
        ReverseConnection reverse_connection = 50;
        Ping ping = 80;
    }

    message Session {
        bytes challenge_resp = 1;
        bytes node_id = 2;
        bytes public_key = 3;
    }

    message Register {
        /* Listening endpoints */
        repeated Endpoint endpoints = 1;
    }

    message Node {
        /* Remote node ID */
        bytes node_id = 1;
        /* Whether to include public key */
        bool public_key = 2;
    }

    message Slot {
        /* Node slot ID */
        uint32 slot = 1;
        /* Whether to include public key */
        bool public_key = 2;
    }

    message Neighbours {
        uint32 count = 1;
        /* Whether to include public keys */
        bool public_key = 2;
    }

    message ReverseConnection {
        /* Remote node ID */
        bytes node_id = 1;
    }

    message Ping {}
}

/* Responses sent by the server to the client */
message Response {
    uint64 request_id = 1;
    StatusCode code = 2;

    oneof kind {
        Challenge challenge = 10;
        Session session = 11;
        Register register = 20;
        Node node = 30;
        Neighbours neighbours = 40;
        Pong pong = 80;
    }

    /* Challenge newly-connected nodes */
    message Challenge {
        enum Kind {
            UNDEFINED = 0;
            SHA3_512_LEADING_ZEROS = 10;
        }

        string version = 1;
        /* Capabilities bit field */
        uint64 caps = 2;

        Kind kind = 3;
        uint64 difficulty = 4;
        bytes challenge = 5;
    }

    /* Session ACK */
    message Session {}

    /* Registered endpoints */
    message Register {
        /* Discovered endpoints */
        repeated Endpoint endpoints = 1;
    }

    /* Node information */
    message Node {
        bytes node_id = 2;
        bytes public_key = 3;
        repeated Endpoint endpoints = 4;
        uint32 seen_ts = 5;
        uint32 slot = 6;
    }

    /* Neighbourhood */
    message Neighbours {
        repeated Node nodes = 1;
    }

    message ReverseConnection {}

    message Pong {}
}

/* Control messages (w/o response) sent by server to the client */
message Control {
    oneof kind {
        ReverseConnection reverse_connection = 10;
        PauseForwarding pause_forwarding = 20;
        ResumeForwarding resume_forwarding = 21;
        StopForwarding stop_forwarding = 22;
    }

    /* Connect to another node */
    message ReverseConnection {
        bytes node_id = 1;
        repeated Endpoint endpoints = 2;
    }

    message PauseForwarding {
        uint32 slot = 1;
    }

    message ResumeForwarding {
        uint32 slot = 1;
    }

    message StopForwarding {
        uint32 slot = 1;
        StatusCode code = 3;
    }
}

enum StatusCode {
    UNDEFINED = 0;
    OK = 200;
    BAD_REQUEST = 400;
    UNAUTHORIZED = 401;
    NOT_FOUND = 404;
    TIMEOUT = 408;
    CONFLICT = 409;
    PAYLOAD_TOO_LARGE = 413;
    TOO_MANY_REQUESTS = 429;
    SERVER_ERROR = 500;
    GATEWAY_TIMEOUT = 504;
}

enum Protocol {
    UNSUPPORTED = 0;
    TCP = 6;
    UDP = 17;
}

message Endpoint {
    Protocol protocol = 1;
    string address = 2;
    uint32 port = 3;
}
