diff --git a/.github/workflows/rust.yml b/.github/workflows/rust.yml
index 042af50..3659f63 100644
--- a/.github/workflows/rust.yml
+++ b/.github/workflows/rust.yml
@@ -11,7 +11,7 @@ on:
       - release/*
 
 env:
-  rust_stable: 1.64.0
+  rust_stable: 1.68.2
 
 jobs:
   build:
@@ -35,12 +35,12 @@ jobs:
           toolchain: ${{ env.rust_stable }}
           components: rustfmt, clippy
 
-#      - name: Install openssl ( Windows only )
-#        if: runner.os == 'Windows'
-#        run: |
-#          vcpkg install openssl:x64-windows openssl:x64-windows-static
-#          vcpkg list
-#          vcpkg integrate install
+      #      - name: Install openssl ( Windows only )
+      #        if: runner.os == 'Windows'
+      #        run: |
+      #          vcpkg install openssl:x64-windows openssl:x64-windows-static
+      #          vcpkg list
+      #          vcpkg integrate install
 
       - name: Unit tests
         uses: actions-rs/cargo@v1
diff --git a/client/examples/perf.rs b/client/examples/perf.rs
index 186e702..91416f5 100644
--- a/client/examples/perf.rs
+++ b/client/examples/perf.rs
@@ -845,7 +845,6 @@ mod relaying {
 
         let records = load_scenario(&cmd.scenario_file)?;
         let scenarios = (0..cmd.requestors)
-            .into_iter()
             .map(|_| create_scenario(records.clone(), &mut clients))
             .collect::<Result<Vec<Scenario>, _>>()?;
 
diff --git a/client/examples/saturate.rs b/client/examples/saturate.rs
index 11c6c82..0e9d825 100644
--- a/client/examples/saturate.rs
+++ b/client/examples/saturate.rs
@@ -307,8 +307,8 @@ async fn sample_state(node_id: NodeId, state: State, delay: Duration, time: Dura
         };
 
         for value in values {
-            output.write(value.join(",").as_bytes()).await.unwrap();
-            output.write(b"\n").await.unwrap();
+            let _ = output.write(value.join(",").as_bytes()).await.unwrap();
+            let _ = output.write(b"\n").await.unwrap();
         }
 
         if Instant::now() >= deadline {
diff --git a/client/src/session.rs b/client/src/session.rs
index 31b0ccc..601f927 100644
--- a/client/src/session.rs
+++ b/client/src/session.rs
@@ -191,7 +191,7 @@ impl Session {
             // We need only one response.
             // Note: futures are asynchronous, because we shouldn't wait for ping timeout
             //       in case of lost packets.
-            futures::future::select_ok((0..3).into_iter().map(|i| {
+            futures::future::select_ok((0..3).map(|i| {
                 async move {
                     tokio::time::sleep(Duration::from_millis(200 * i)).await;
                     self.ping().await
diff --git a/crates/proto/src/codec/datagram.rs b/crates/proto/src/codec/datagram.rs
index 90400b5..7531b2c 100644
--- a/crates/proto/src/codec/datagram.rs
+++ b/crates/proto/src/codec/datagram.rs
@@ -157,9 +157,9 @@ mod tests {
             .encode_length_delimited(&mut buf)
             .expect("serialization failed");
 
-        assert!(match codec.decode(&mut buf) {
-            Err(Error::Decode(DecodeError::PrefixTooLong)) => true,
-            _ => false,
-        })
+        assert!(matches!(
+            codec.decode(&mut buf),
+            Err(Error::Decode(DecodeError::PrefixTooLong))
+        ))
     }
 }
diff --git a/crates/stack/src/network.rs b/crates/stack/src/network.rs
index 5a1588e..f5915b2 100644
--- a/crates/stack/src/network.rs
+++ b/crates/stack/src/network.rs
@@ -1185,7 +1185,7 @@ mod tests {
                 Ok(_) => println!("Connection({i}) successful"),
                 Err(e) => {
                     if i != u16::MAX {
-                        panic!("Connection failed! Error: {}", e.to_string());
+                        panic!("Connection failed! Error: {}", e);
                     };
 
                     let expected = error::Error::Other("no ports available".into());
diff --git a/crates/stack/src/socket.rs b/crates/stack/src/socket.rs
index f01112a..39eb7b1 100644
--- a/crates/stack/src/socket.rs
+++ b/crates/stack/src/socket.rs
@@ -156,7 +156,7 @@ impl SocketEndpoint {
     }
 }
 
-#[allow(clippy::derive_hash_xor_eq)]
+#[allow(clippy::derived_hash_with_manual_eq)]
 impl Hash for SocketEndpoint {
     fn hash<H: Hasher>(&self, state: &mut H) {
         match self {
diff --git a/server/tests/test_broadcasts.rs b/server/tests/test_broadcasts.rs
index eae8db0..a9d7176 100644
--- a/server/tests/test_broadcasts.rs
+++ b/server/tests/test_broadcasts.rs
@@ -46,7 +46,7 @@ async fn test_neighbourhood() -> anyhow::Result<()> {
         .collect();
 
     // Node itself isn't returned in it's neighbourhood.
-    assert_eq!(ids.contains(&node_id), false);
+    assert!(!ids.contains(&node_id));
 
     // No duplicated nodes in neighbourhood.
     assert_eq!(ids.len(), 5);
@@ -96,7 +96,7 @@ async fn test_neighbourhood_too_big_neighbourhood_request() -> anyhow::Result<()
         .collect();
 
     // Node itself isn't returned in it's neighbourhood.
-    assert_eq!(ids.contains(&node_id), false);
+    assert!(!ids.contains(&node_id));
 
     // Node neighbourhood consists of all nodes beside requesting node.
     assert_eq!(ids.len(), 2);
diff --git a/server/tests/test_expired_session.rs b/server/tests/test_expired_session.rs
index 96ef507..bf1df48 100644
--- a/server/tests/test_expired_session.rs
+++ b/server/tests/test_expired_session.rs
@@ -268,11 +268,11 @@ async fn test_restart_after_neighborhood_changed() -> anyhow::Result<()> {
     let marker1 = spawn_receive_for_client(&client1, "Client1").await?;
     let marker2 = spawn_receive_for_client(&client2, "Client2").await?;
 
-    let _keep1 = check_broadcast(&client1, &client2, marker2.clone(), 2)
+    check_broadcast(&client1, &client2, marker2.clone(), 2)
         .await
         .unwrap();
 
-    let _keep2 = check_broadcast(&client2, &client1, marker1.clone(), 2)
+    check_broadcast(&client2, &client1, marker1.clone(), 2)
         .await
         .unwrap();
 
@@ -282,7 +282,6 @@ async fn test_restart_after_neighborhood_changed() -> anyhow::Result<()> {
     let crypto = client2.config.crypto.clone();
 
     client2.shutdown().await.unwrap();
-    drop(_keep2);
 
     println!("Waiting for session cleanup on Client1.");
 
@@ -356,11 +355,11 @@ async fn test_fast_restart_unreliable() -> anyhow::Result<()> {
     let marker1 = spawn_receive_for_client(&client1, "Client1").await?;
     let marker2 = spawn_receive_for_client(&client2, "Client2").await?;
 
-    let _keep1 = check_broadcast(&client1, &client2, marker2.clone(), 2)
+    check_broadcast(&client1, &client2, marker2.clone(), 2)
         .await
         .unwrap();
 
-    let _keep2 = check_broadcast(&client2, &client1, marker1.clone(), 2)
+    check_broadcast(&client2, &client1, marker1.clone(), 2)
         .await
         .unwrap();
 
@@ -370,7 +369,6 @@ async fn test_fast_restart_unreliable() -> anyhow::Result<()> {
     let crypto = client2.config.crypto.clone();
 
     client2.shutdown().await.unwrap();
-    drop(_keep2);
 
     println!("Waiting for session cleanup on Client1.");
 
